// notice: file automatically generated by rpcgen
// do not change it unless you know what you're doing

/* tslint:disable variable-name */

import { ISocketEvent } from './socket_helper'

// ICoinBalance
export interface ICoinBalance {
  confirmed: string
  unconfirmed: string
}

// IBlockHeader
export interface IBlockHeader {
  nonce: number
  prev_block_hash: string
  timestamp: number
  merkle_root: string
  block_height: number
  utxo_root: string
  version: number
  bits: number
}

export class ElectrumProtocol {
  static libname: string = 'javascript client'
  static version: string = '1.0'
  static hash: string = '2e2cdaf4905e8d83e34693d228f6eef5335067021268fe561e6eaf94c33f6cc0'
  client: ISocketEvent

  constructor (client: ISocketEvent) {
    this.client = client
    this.client.subscribe.on('close', () => { this.onClose() })
  }

  // server_version
  public server_version (client_version: string, protocol_version: string = '1.0'): Promise<string> {
    return this.client.request('server.version', [ client_version, protocol_version ])
  }

  // server_banner
  public server_banner (): Promise<string> {
    return this.client.request('server.banner', [  ])
  }

  // server_donationAddress
  public server_donationAddress (): Promise<string> {
    return this.client.request('server.donation_address', [  ])
  }

  // server_features
  public server_features (): Promise<object> {
    return this.client.request('server.features', [  ])
  }

  // They donâ€™t send notifications yet
  public server_peers_subscribe (): Promise<Array<object>> {
    return this.client.request('server.peers.subscribe', [  ])
  }

  // blockchain_transaction_broadcast
  public blockchain_transaction_broadcast (rawtx: string): Promise<string> {
    return this.client.request('blockchain.transaction.broadcast', [ rawtx ])
  }

  // blockchain_transaction_getMerkle
  public blockchain_transaction_getMerkle (tx_hash: string, tx_height: number): Promise<string> {
    return this.client.request('blockchain.transaction.get_merkle', [ tx_hash, tx_height ])
  }

  // blockchain_transaction_get
  public blockchain_transaction_get (tx_hash: string): Promise<string> {
    return this.client.request('blockchain.transaction.get', [ tx_hash ])
  }

  // blockchain_estimatefee
  public blockchain_estimatefee (target_block: number): Promise<number> {
    return this.client.request('blockchain.estimatefee', [ target_block ])
  }

  // blockchain_block_getHeader
  public blockchain_block_getHeader (height: number): Promise<object> {
    return this.client.request('blockchain.block.get_header', [ height ])
  }

  // blockchain_block_getChunk
  public blockchain_block_getChunk (index: number): Promise<string> {
    return this.client.request('blockchain.block.get_chunk', [ index ])
  }

  // blockchain_address_getBalance
  public blockchain_address_getBalance (address: string): Promise<ICoinBalance> {
    return this.client.request('blockchain.address.get_balance', [ address ])
  }

  // blockchain_address_getHistory
  public blockchain_address_getHistory (address: string): Promise<Array<object>> {
    return this.client.request('blockchain.address.get_history', [ address ])
  }

  // blockchain_address_getMempool
  public blockchain_address_getMempool (address: string): Promise<Array<object>> {
    return this.client.request('blockchain.address.get_mempool', [ address ])
  }

  // blockchain_address_listunspent
  public blockchain_address_listunspent (address: string): Promise<Array<object>> {
    return this.client.request('blockchain.address.listunspent', [ address ])
  }

  // blockchain_address_subscribe
  public blockchain_address_subscribe (address: string): Promise<string> {
    return this.client.request('blockchain.address.subscribe', [ address ])
  }

  // blockchain_headers_subscribe
  public blockchain_headers_subscribe (): Promise<IBlockHeader> {
    return this.client.request('blockchain.headers.subscribe', [  ])
  }

  onClose (): void {
    const list: Array<string> = []
    list.push('blockchain.address.subscribe')
    list.push('blockchain.headers.subscribe')
    list.forEach(event => this.client.subscribe.removeAllListeners(event))
  }
}

export namespace validate {
  export const ICoinBalance = ( obj: object ): boolean => {
    if (!('confirmed' in obj)) return false
    if (!('unconfirmed' in obj)) return false
    return true
  }
  export const IBlockHeader = ( obj: object ): boolean => {
    if (!('nonce' in obj)) return false
    if (!('prev_block_hash' in obj)) return false
    if (!('timestamp' in obj)) return false
    if (!('merkle_root' in obj)) return false
    if (!('block_height' in obj)) return false
    if (!('utxo_root' in obj)) return false
    if (!('version' in obj)) return false
    if (!('bits' in obj)) return false
    return true
  }
}
