/* tslint:disable variable-name */

// IMPORTANT: file automatically generated by rpcgen
// do not change it unless you know what you're doing

import { IJSONRPCSocketClient } from '../json-rpc-socket/client'

// ----------------
// interfaces

// result of &#39;blockchain.scripthash.get_balance&#39;
export interface IScripthashBalance {
  confirmed: string
  unconfirmed: string
}

// result of &#39;blockchain.headers.subscribe&#39;
export interface IBlockHeader {
  hex: string
  height: number
}

// result of &#39;blockchain.transaction.get_merkle&#39;
export interface ITxMerkle {
  block_height: number
  merkle: Array<string>
  pos: number
}

// result of &#39;blockchain.scripthash.get_history&#39;
export interface ITxInfoHistory {
  height: number
  tx_hash: string
}

// result of &#39;blockchain.scripthash.get_mempool&#39;
export interface ITxInfoMempool {
  height: number
  tx_hash: string
  fee: number
}

// result of &#39;blockchain.scripthash.listunspent&#39;
export interface ITxInfoUnspent {
  height: number
  tx_pos: number
  tx_hash: string
  value: number
}

// ----------------
// electrum protocol

export class ElectrumProtocol {
  static libname: string = 'javascript client'
  static version: string = '1.2'
  static hash: string = '9abd00e899a8eb82382c7651d2ac94882e6b8349ee9c8352569bf22fe853caf0'
  private client: IJSONRPCSocketClient

  constructor (client: IJSONRPCSocketClient) {
    this.client = client
    this.client.events.on('close', () => { this._onClose() })
  }

  // ----------------
  // lifecycle handlers

  private _onClose (): void {
    const list: Array<string> = []
    list.push('blockchain.headers.subscribe')
    list.push('blockchain.scripthash.subscribe')
    list.forEach(event => this.client.events.removeAllListeners(event))
  }

  // ----------------
  // electrum methods

  // Identify the client to the server and negotiate the protocol version.
  public server_version (client_name: string, protocol_version: [string,string] = ['1.2', '1.4']): Promise<string> {
    return this.client.request('server.version', [ client_name, protocol_version ])
  }

  // Return a banner to be shown in the Electrum console.
  public server_banner (): Promise<string> {
    return this.client.request('server.banner', [])
  }

  // Return a server donation address.
  public server_donationAddress (): Promise<string> {
    return this.client.request('server.donation_address', [])
  }

  // Return a list of features and services supported by the server.
  public server_features (): Promise<object> {
    return this.client.request('server.features', [])
  }

  // Return a list of peer servers. Despite the name this is not a subscription and the server must send no notifications.
  public server_peers_subscribe (): Promise<Array<Array<string>>> {
    return this.client.request('server.peers.subscribe', [])
  }

  // Broadcast a transaction to the network.
  public blockchain_transaction_broadcast (rawtx: string): Promise<string> {
    return this.client.request('blockchain.transaction.broadcast', [ rawtx ])
  }

  // Return the merkle branch to a confirmed transaction given its hash and height.
  public blockchain_transaction_getMerkle (tx_hash: string, tx_height: number): Promise<ITxMerkle> {
    return this.client.request('blockchain.transaction.get_merkle', [ tx_hash, tx_height ])
  }

  // Return a raw transaction.
  public blockchain_transaction_get (tx_hash: string, verbose: boolean = false): Promise<string> {
    return this.client.request('blockchain.transaction.get', [ tx_hash, verbose ])
  }

  // Return the estimated transaction fee per kilobyte for a transaction to be confirmed within a certain number of blocks.
  public blockchain_estimatefee (target_block: number): Promise<number> {
    return this.client.request('blockchain.estimatefee', [ target_block ])
  }

  // Return the deserialized header of the block at the given height.
  public blockchain_block_getHeader (height: number): Promise<object> {
    return this.client.request('blockchain.block.get_header', [ height ])
  }

  // Subscribe to receive block headers when a new block is found.
  public blockchain_headers_subscribe (raw: boolean = true): Promise<IBlockHeader> {
    return this.client.request('blockchain.headers.subscribe', [ raw ])
  }

  // Return the confirmed and unconfirmed balances of a script hash.
  public blockchain_scripthash_getBalance (scripthash: string): Promise<IScripthashBalance> {
    return this.client.request('blockchain.scripthash.get_balance', [ scripthash ])
  }

  // Return the confirmed and unconfirmed history of a script hash.
  public blockchain_scripthash_getHistory (scripthash: string): Promise<Array<ITxInfoHistory>> {
    return this.client.request('blockchain.scripthash.get_history', [ scripthash ])
  }

  // Return the unconfirmed transactions of a script hash.
  public blockchain_scripthash_getMempool (scripthash: string): Promise<Array<ITxInfoMempool>> {
    return this.client.request('blockchain.scripthash.get_mempool', [ scripthash ])
  }

  // A list of unspent outputs in blockchain order. This function takes the mempool into account.
  public blockchain_scripthash_listunspent (scripthash: string): Promise<Array<ITxInfoUnspent>> {
    return this.client.request('blockchain.scripthash.listunspent', [ scripthash ])
  }

  // Subscribe to a script hash.
  public blockchain_scripthash_subscribe (scripthash: string): Promise<string> {
    return this.client.request('blockchain.scripthash.subscribe', [ scripthash ])
  }

  // server_ping
  public server_ping (): Promise<void> {
    return this.client.request('server.ping', [])
  }

  // Return a histogram of the fee rates paid by transactions in the memory pool, weighted by transaction size. [fee, vsize] pairs
  public mempool_getFeeHistogram (): Promise<Array<[number, number]>> {
    return this.client.request('mempool.get_fee_histogram', [])
  }
}

// ----------------
// electrum methods

export namespace validate {
  export const IScripthashBalance = (obj: object): boolean => {
    // TODO: const props = [ &#39;confirmed&#39;, &#39;unconfirmed&#39; ]
    return [
      'confirmed',
      'unconfirmed'
    ].every(prop => prop in obj)
  }
  export const IBlockHeader = (obj: object): boolean => {
    // TODO: const props = [ &#39;hex&#39;, &#39;height&#39; ]
    return [
      'hex',
      'height'
    ].every(prop => prop in obj)
  }
  export const ITxMerkle = (obj: object): boolean => {
    // TODO: const props = [ &#39;block_height&#39;, &#39;merkle&#39;, &#39;pos&#39; ]
    return [
      'block_height',
      'merkle',
      'pos'
    ].every(prop => prop in obj)
  }
  export const ITxInfoHistory = (obj: object): boolean => {
    // TODO: const props = [ &#39;height&#39;, &#39;tx_hash&#39; ]
    return [
      'height',
      'tx_hash'
    ].every(prop => prop in obj)
  }
  export const ITxInfoMempool = (obj: object): boolean => {
    // TODO: const props = [ &#39;height&#39;, &#39;tx_hash&#39;, &#39;fee&#39; ]
    return [
      'height',
      'tx_hash',
      'fee'
    ].every(prop => prop in obj)
  }
  export const ITxInfoUnspent = (obj: object): boolean => {
    // TODO: const props = [ &#39;height&#39;, &#39;tx_pos&#39;, &#39;tx_hash&#39;, &#39;value&#39; ]
    return [
      'height',
      'tx_pos',
      'tx_hash',
      'value'
    ].every(prop => prop in obj)
  }
}
