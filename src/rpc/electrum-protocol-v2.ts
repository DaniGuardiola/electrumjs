/* tslint:disable variable-name */

// IMPORTANT: file automatically generated by rpcgen
// do not change it unless you know what you're doing

import { ISocketClient } from '../client'

// ----------------
// interfaces

// ICoinBalance
export interface ICoinBalance {
  confirmed: string
  unconfirmed: string
}

// IBlockHeader
export interface IBlockHeader {
  nonce: number
  prev_block_hash: string
  timestamp: number
  merkle_root: string
  block_height: number
  utxo_root: string
  version: number
  bits: number
}

// ----------------
// electrum protocol

export class ElectrumProtocol {
  static libname: string = 'javascript client'
  static version: string = '1.0'
  static hash: string = '3639bff641b745ea5ce7ae1e44dfbfe0ddb969772ce4b87e806689af0438f84d'
  private client: ISocketClient

  constructor (client: ISocketClient) {
    this.client = client
    this.client.notifications.on('close', () => { this._onClose() })
  }

  // ----------------
  // lifecycle handlers

  private _onClose (): void {
    const list: Array<string> = []
    list.push('blockchain.address.subscribe')
    list.push('blockchain.headers.subscribe')
    list.forEach(event => this.client.notifications.removeAllListeners(event))
  }

  // ----------------
  // electrum methods

  // server_version
  public server_version (client_version: string, protocol_version: string = '1.0'): Promise<string> {
    return this.client.request('server.version', [ client_version, protocol_version ])
  }

  // server_banner
  public server_banner (): Promise<string> {
    return this.client.request('server.banner', [])
  }

  // server_donationAddress
  public server_donationAddress (): Promise<string> {
    return this.client.request('server.donation_address', [])
  }

  // server_features
  public server_features (): Promise<object> {
    return this.client.request('server.features', [])
  }

  // Notifications are not yet supported
  public server_peers_subscribe (): Promise<Array<object>> {
    return this.client.request('server.peers.subscribe', [])
  }

  // blockchain_transaction_broadcast
  public blockchain_transaction_broadcast (rawtx: string): Promise<string> {
    return this.client.request('blockchain.transaction.broadcast', [ rawtx ])
  }

  // blockchain_transaction_getMerkle
  public blockchain_transaction_getMerkle (tx_hash: string, tx_height: number): Promise<string> {
    return this.client.request('blockchain.transaction.get_merkle', [ tx_hash, tx_height ])
  }

  // blockchain_transaction_get
  public blockchain_transaction_get (tx_hash: string): Promise<string> {
    return this.client.request('blockchain.transaction.get', [ tx_hash ])
  }

  // blockchain_estimatefee
  public blockchain_estimatefee (target_block: number): Promise<number> {
    return this.client.request('blockchain.estimatefee', [ target_block ])
  }

  // blockchain_block_getHeader
  public blockchain_block_getHeader (height: number): Promise<object> {
    return this.client.request('blockchain.block.get_header', [ height ])
  }

  // blockchain_block_getChunk
  public blockchain_block_getChunk (index: number): Promise<string> {
    return this.client.request('blockchain.block.get_chunk', [ index ])
  }

  // blockchain_address_getBalance
  public blockchain_address_getBalance (address: string): Promise<ICoinBalance> {
    return this.client.request('blockchain.address.get_balance', [ address ])
  }

  // blockchain_address_getHistory
  public blockchain_address_getHistory (address: string): Promise<Array<object>> {
    return this.client.request('blockchain.address.get_history', [ address ])
  }

  // blockchain_address_getMempool
  public blockchain_address_getMempool (address: string): Promise<Array<object>> {
    return this.client.request('blockchain.address.get_mempool', [ address ])
  }

  // blockchain_address_listunspent
  public blockchain_address_listunspent (address: string): Promise<Array<object>> {
    return this.client.request('blockchain.address.listunspent', [ address ])
  }

  // blockchain_address_subscribe
  public blockchain_address_subscribe (address: string): Promise<string> {
    return this.client.request('blockchain.address.subscribe', [ address ])
  }

  // blockchain_headers_subscribe
  public blockchain_headers_subscribe (): Promise<IBlockHeader> {
    return this.client.request('blockchain.headers.subscribe', [])
  }
}

// ----------------
// electrum methods

export namespace validate {
  export const ICoinBalance = (obj: object): boolean => {
    // TODO: const props = [ &#39;confirmed&#39;, &#39;unconfirmed&#39; ]
    return [
      'confirmed',
      'unconfirmed',
    ].every(prop => prop in obj)
  }
  export const IBlockHeader = (obj: object): boolean => {
    // TODO: const props = [ &#39;nonce&#39;, &#39;prev_block_hash&#39;, &#39;timestamp&#39;, &#39;merkle_root&#39;, &#39;block_height&#39;, &#39;utxo_root&#39;, &#39;version&#39;, &#39;bits&#39; ]
    return [
      'nonce',
      'prev_block_hash',
      'timestamp',
      'merkle_root',
      'block_height',
      'utxo_root',
      'version',
      'bits',
    ].every(prop => prop in obj)
  }
}
