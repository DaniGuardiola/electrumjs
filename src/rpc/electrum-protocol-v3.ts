// notice: file automatically generated by rpcgen
// do not change it unless you know what you're doing

/* tslint:disable variable-name */

import { ISocketClient } from '../lib/socket-utils'

// ICoinBalance
export interface ICoinBalance {
  confirmed: string
  unconfirmed: string
}

// IBlockHeader
export interface IBlockHeader {
  nonce: number
  prev_block_hash: string
  timestamp: number
  merkle_root: string
  block_height: number
  utxo_root: string
  version: number
  bits: number
}

// result of blockchain.scripthash.get_mempool
export interface ITxInfoMempool {
  tx_hash: string
  height: number
  fee: number
}

// result of blockchain.scripthash.listunspent
export interface ITxInfoUnspent {
  tx_pos: number
  value: number
  tx_hash: string
  height: number
}

export class ElectrumProtocol {
  static libname: string = 'javascript client'
  static version: string = '1.1'
  static hash: string = 'ec46b1a3de2ce38cac86cdd6a56d91a7d4aaf8942f7180e08684021619a2f31c'
  client: ISocketClient

  constructor (client: ISocketClient) {
    this.client = client
    this.client.subscribe.on('close', () => { this.onClose() })
  }

  // String identifying the server software.
  public server_version (client_name: string, protocol_version: string = '1.1'): Promise<string> {
    return this.client.request('server.version', [ client_name, protocol_version ])
  }

  // server_banner
  public server_banner (): Promise<string> {
    return this.client.request('server.banner', [])
  }

  // server_donationAddress
  public server_donationAddress (): Promise<string> {
    return this.client.request('server.donation_address', [])
  }

  // server_features
  public server_features (): Promise<object> {
    return this.client.request('server.features', [])
  }

  // Notifications are not yet supported
  public server_peers_subscribe (): Promise<Array<object>> {
    return this.client.request('server.peers.subscribe', [])
  }

  // blockchain_transaction_broadcast
  public blockchain_transaction_broadcast (rawtx: string): Promise<string> {
    return this.client.request('blockchain.transaction.broadcast', [ rawtx ])
  }

  // blockchain_transaction_getMerkle
  public blockchain_transaction_getMerkle (tx_hash: string, tx_height: number): Promise<string> {
    return this.client.request('blockchain.transaction.get_merkle', [ tx_hash, tx_height ])
  }

  // blockchain_transaction_get
  public blockchain_transaction_get (tx_hash: string): Promise<string> {
    return this.client.request('blockchain.transaction.get', [ tx_hash ])
  }

  // blockchain_estimatefee
  public blockchain_estimatefee (target_block: number): Promise<number> {
    return this.client.request('blockchain.estimatefee', [ target_block ])
  }

  // blockchain_block_getHeader
  public blockchain_block_getHeader (height: number): Promise<object> {
    return this.client.request('blockchain.block.get_header', [ height ])
  }

  // blockchain_block_getChunk
  public blockchain_block_getChunk (index: number): Promise<string> {
    return this.client.request('blockchain.block.get_chunk', [ index ])
  }

  // blockchain_address_getBalance
  public blockchain_address_getBalance (address: string): Promise<ICoinBalance> {
    return this.client.request('blockchain.address.get_balance', [ address ])
  }

  // blockchain_address_getHistory
  public blockchain_address_getHistory (address: string): Promise<Array<object>> {
    return this.client.request('blockchain.address.get_history', [ address ])
  }

  // blockchain_address_getMempool
  public blockchain_address_getMempool (address: string): Promise<Array<object>> {
    return this.client.request('blockchain.address.get_mempool', [ address ])
  }

  // blockchain_address_listunspent
  public blockchain_address_listunspent (address: string): Promise<Array<object>> {
    return this.client.request('blockchain.address.listunspent', [ address ])
  }

  // blockchain_address_subscribe
  public blockchain_address_subscribe (address: string): Promise<string> {
    return this.client.request('blockchain.address.subscribe', [ address ])
  }

  // blockchain_headers_subscribe
  public blockchain_headers_subscribe (): Promise<IBlockHeader> {
    return this.client.request('blockchain.headers.subscribe', [])
  }

  // Confirmed and unconfirmed balances of a script hash.
  public blockchain_scripthash_getBalance (scripthash: string): Promise<ICoinBalance> {
    return this.client.request('blockchain.scripthash.get_balance', [ scripthash ])
  }

  // Confirmed and unconfirmed history of a script hash.
  public blockchain_scripthash_getHistory (scripthash: string): Promise<Array<object>> {
    return this.client.request('blockchain.scripthash.get_history', [ scripthash ])
  }

  // List of unconfirmed transactions of a script hash.
  public blockchain_scripthash_getMempool (scripthash: string): Promise<Array<ITxInfoMempool>> {
    return this.client.request('blockchain.scripthash.get_mempool', [ scripthash ])
  }

  // List of unspent outputs in blockchain order. This function takes the mempool into account.
  public blockchain_scripthash_listunspent (scripthash: string): Promise<Array<ITxInfoUnspent>> {
    return this.client.request('blockchain.scripthash.listunspent', [ scripthash ])
  }

  // blockchain_scripthash_subscribe
  public blockchain_scripthash_subscribe (scripthash: string): Promise<object> {
    return this.client.request('blockchain.scripthash.subscribe', [ scripthash ])
  }

  // server_addPeer
  public server_addPeer (features: object): Promise<object> {
    return this.client.request('server.add_peer', [ features ])
  }

  onClose (): void {
    const list: Array<string> = []
    list.push('blockchain.address.subscribe')
    list.push('blockchain.headers.subscribe')
    list.push('blockchain.scripthash.subscribe')
    list.forEach(event => this.client.subscribe.removeAllListeners(event))
  }
}

export namespace validate {
  export const ICoinBalance = (obj: object): boolean => {
    if (!('confirmed' in obj)) return false
    if (!('unconfirmed' in obj)) return false
    return true
  }
  export const IBlockHeader = (obj: object): boolean => {
    if (!('nonce' in obj)) return false
    if (!('prev_block_hash' in obj)) return false
    if (!('timestamp' in obj)) return false
    if (!('merkle_root' in obj)) return false
    if (!('block_height' in obj)) return false
    if (!('utxo_root' in obj)) return false
    if (!('version' in obj)) return false
    if (!('bits' in obj)) return false
    return true
  }
  export const ITxInfoMempool = (obj: object): boolean => {
    if (!('tx_hash' in obj)) return false
    if (!('height' in obj)) return false
    if (!('fee' in obj)) return false
    return true
  }
  export const ITxInfoUnspent = (obj: object): boolean => {
    if (!('tx_pos' in obj)) return false
    if (!('value' in obj)) return false
    if (!('tx_hash' in obj)) return false
    if (!('height' in obj)) return false
    return true
  }
}
