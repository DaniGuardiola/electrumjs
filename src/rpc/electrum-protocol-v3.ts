/* tslint:disable variable-name */

// IMPORTANT: file automatically generated by rpcgen
// do not change it unless you know what you're doing

import { ISocketClient } from '../client'

// ----------------
// interfaces

// ICoinBalance
export interface ICoinBalance {
  confirmed: string
  unconfirmed: string
}

// IBlockHeader
export interface IBlockHeader {
  nonce: number
  prev_block_hash: string
  timestamp: number
  merkle_root: string
  block_height: number
  utxo_root: string
  version: number
  bits: number
}

// result of blockchain.scripthash.get_mempool
export interface ITxInfoMempool {
  tx_hash: string
  height: number
  fee: number
}

// result of blockchain.scripthash.listunspent
export interface ITxInfoUnspent {
  tx_pos: number
  value: number
  tx_hash: string
  height: number
}

// ----------------
// electrum protocol

export class ElectrumProtocol {
  static libname: string = 'javascript client'
  static version: string = '1.1'
  static hash: string = 'ec46b1a3de2ce38cac86cdd6a56d91a7d4aaf8942f7180e08684021619a2f31c'
  private client: ISocketClient

  constructor (client: ISocketClient) {
    this.client = client
    this.client.notifications.on('close', () => { this._onClose() })
  }

  // ----------------
  // lifecycle handlers

  private _onClose (): void {
    const list: Array<string> = []
    list.push('blockchain.address.subscribe')
    list.push('blockchain.headers.subscribe')
    list.push('blockchain.scripthash.subscribe')
    list.forEach(event => this.client.notifications.removeAllListeners(event))
  }

  // ----------------
  // electrum methods

  // String identifying the server software.
  public server_version (client_name: string, protocol_version: string = '1.1'): Promise<string> {
    return this.client.request('server.version', [ client_name, protocol_version ])
  }

  // server_banner
  public server_banner (): Promise<string> {
    return this.client.request('server.banner', [])
  }

  // server_donationAddress
  public server_donationAddress (): Promise<string> {
    return this.client.request('server.donation_address', [])
  }

  // server_features
  public server_features (): Promise<object> {
    return this.client.request('server.features', [])
  }

  // Notifications are not yet supported
  public server_peers_subscribe (): Promise<Array<object>> {
    return this.client.request('server.peers.subscribe', [])
  }

  // blockchain_transaction_broadcast
  public blockchain_transaction_broadcast (rawtx: string): Promise<string> {
    return this.client.request('blockchain.transaction.broadcast', [ rawtx ])
  }

  // blockchain_transaction_getMerkle
  public blockchain_transaction_getMerkle (tx_hash: string, tx_height: number): Promise<string> {
    return this.client.request('blockchain.transaction.get_merkle', [ tx_hash, tx_height ])
  }

  // blockchain_transaction_get
  public blockchain_transaction_get (tx_hash: string): Promise<string> {
    return this.client.request('blockchain.transaction.get', [ tx_hash ])
  }

  // blockchain_estimatefee
  public blockchain_estimatefee (target_block: number): Promise<number> {
    return this.client.request('blockchain.estimatefee', [ target_block ])
  }

  // blockchain_block_getHeader
  public blockchain_block_getHeader (height: number): Promise<object> {
    return this.client.request('blockchain.block.get_header', [ height ])
  }

  // blockchain_block_getChunk
  public blockchain_block_getChunk (index: number): Promise<string> {
    return this.client.request('blockchain.block.get_chunk', [ index ])
  }

  // blockchain_address_getBalance
  public blockchain_address_getBalance (address: string): Promise<ICoinBalance> {
    return this.client.request('blockchain.address.get_balance', [ address ])
  }

  // blockchain_address_getHistory
  public blockchain_address_getHistory (address: string): Promise<Array<object>> {
    return this.client.request('blockchain.address.get_history', [ address ])
  }

  // blockchain_address_getMempool
  public blockchain_address_getMempool (address: string): Promise<Array<object>> {
    return this.client.request('blockchain.address.get_mempool', [ address ])
  }

  // blockchain_address_listunspent
  public blockchain_address_listunspent (address: string): Promise<Array<object>> {
    return this.client.request('blockchain.address.listunspent', [ address ])
  }

  // blockchain_address_subscribe
  public blockchain_address_subscribe (address: string): Promise<string> {
    return this.client.request('blockchain.address.subscribe', [ address ])
  }

  // blockchain_headers_subscribe
  public blockchain_headers_subscribe (): Promise<IBlockHeader> {
    return this.client.request('blockchain.headers.subscribe', [])
  }

  // Confirmed and unconfirmed balances of a script hash.
  public blockchain_scripthash_getBalance (scripthash: string): Promise<ICoinBalance> {
    return this.client.request('blockchain.scripthash.get_balance', [ scripthash ])
  }

  // Confirmed and unconfirmed history of a script hash.
  public blockchain_scripthash_getHistory (scripthash: string): Promise<Array<object>> {
    return this.client.request('blockchain.scripthash.get_history', [ scripthash ])
  }

  // List of unconfirmed transactions of a script hash.
  public blockchain_scripthash_getMempool (scripthash: string): Promise<Array<ITxInfoMempool>> {
    return this.client.request('blockchain.scripthash.get_mempool', [ scripthash ])
  }

  // List of unspent outputs in blockchain order. This function takes the mempool into account.
  public blockchain_scripthash_listunspent (scripthash: string): Promise<Array<ITxInfoUnspent>> {
    return this.client.request('blockchain.scripthash.listunspent', [ scripthash ])
  }

  // blockchain_scripthash_subscribe
  public blockchain_scripthash_subscribe (scripthash: string): Promise<object> {
    return this.client.request('blockchain.scripthash.subscribe', [ scripthash ])
  }

  // server_addPeer
  public server_addPeer (features: object): Promise<object> {
    return this.client.request('server.add_peer', [ features ])
  }
}

// ----------------
// electrum methods

export namespace validate {
  export const ICoinBalance = (obj: object): boolean => {
    // TODO: const props = [ &#39;confirmed&#39;, &#39;unconfirmed&#39; ]
    return [
      'confirmed',
      'unconfirmed',
    ].every(prop => prop in obj)
  }
  export const IBlockHeader = (obj: object): boolean => {
    // TODO: const props = [ &#39;nonce&#39;, &#39;prev_block_hash&#39;, &#39;timestamp&#39;, &#39;merkle_root&#39;, &#39;block_height&#39;, &#39;utxo_root&#39;, &#39;version&#39;, &#39;bits&#39; ]
    return [
      'nonce',
      'prev_block_hash',
      'timestamp',
      'merkle_root',
      'block_height',
      'utxo_root',
      'version',
      'bits',
    ].every(prop => prop in obj)
  }
  export const ITxInfoMempool = (obj: object): boolean => {
    // TODO: const props = [ &#39;tx_hash&#39;, &#39;height&#39;, &#39;fee&#39; ]
    return [
      'tx_hash',
      'height',
      'fee',
    ].every(prop => prop in obj)
  }
  export const ITxInfoUnspent = (obj: object): boolean => {
    // TODO: const props = [ &#39;tx_pos&#39;, &#39;value&#39;, &#39;tx_hash&#39;, &#39;height&#39; ]
    return [
      'tx_pos',
      'value',
      'tx_hash',
      'height',
    ].every(prop => prop in obj)
  }
}
